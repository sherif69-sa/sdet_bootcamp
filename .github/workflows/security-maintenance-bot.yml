name: Security Maintenance Bot

on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:
  schedule:
    # Weekly run every Monday at 03:30 UTC.
    - cron: "30 3 * * 1"

permissions:
  actions: read
  contents: read
  issues: write
  security-events: write

jobs:
  secret-scan:
    name: Secret scan (gitleaks)
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd  # v6.0.2
        with:
          fetch-depth: 0

      - name: Run gitleaks
        uses: gitleaks/gitleaks-action@ff98106e4c7b2bc287b24eaf42907196329070c7  # v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_COMMENTS: "false"
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: "true"

      - name: Check SARIF presence
        if: always()
        id: sarif
        run: |
          if [ -f results.sarif ]; then
            echo 'present=true' >> "$GITHUB_OUTPUT"
          else
            echo 'present=false' >> "$GITHUB_OUTPUT"
          fi

      - name: Send SARIF
        if: steps.sarif.outputs.present == 'true'
        uses: github/codeql-action/upload-sarif@89a39a4e59826350b863aa6b6252a07ad50cf83e  # v4
        with:
          sarif_file: results.sarif

  weekly-maintenance-issue:
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: Create or update weekly maintenance issues
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd  # v8.0.0
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const weekOf = new Date().toISOString().slice(0, 10);

            const maintenanceLabel = 'maintenance';
            const enhancementLabel = 'enhancement';
            const weakSpotLabel = 'maintenance:weak-spot';
            const priorityLabel = 'priority:medium';

            const labels = [
              { name: maintenanceLabel, color: '0E8A16', description: 'Automated maintenance tracking' },
              { name: enhancementLabel, color: 'a2eeef', description: 'Feature work and product improvements' },
              { name: weakSpotLabel, color: '5319e7', description: 'Auto-detected maintenance weak spots and follow-up suggestions' },
              { name: 'priority:high', color: 'd93f0b', description: 'High-priority work item' },
              { name: priorityLabel, color: 'fbca04', description: 'Medium-priority work item' },
              { name: 'priority:low', color: '0e8a16', description: 'Low-priority work item' },
            ];

            for (const lbl of labels) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: lbl.name });
              } catch {
                await github.rest.issues.createLabel({ owner, repo, ...lbl });
              }
            }

            const mainTitle = `ðŸ” Weekly security + maintenance checklist (${weekOf})`;
            const mainBody = [
              'This issue is auto-generated to keep the repository secure and continuously updated.',
              '',
              '## Security auto-update checklist',
              '- [ ] Review Dependabot PRs and approve any major upgrades.',
              '- [ ] Confirm all security workflows are green in Actions (security.yml, osv-scanner.yml, security-maintenance-bot.yml).',
              '- [ ] Review GitHub code scanning alerts and close/resolution as needed.',
              '- [ ] Review open vulnerabilities in Dependency graph.',
              '',
              '## Suggested enhancement pipeline',
              '- [ ] Open at least 1 enhancement issue from customer/user feedback.',
              '- [ ] Tag enhancements with `enhancement` and priority labels.',
              '- [ ] Link roadmap updates in `docs/roadmap.md`.',
              '',
              '## Quick links',
              `- Code scanning: https://github.com/${owner}/${repo}/security/code-scanning`,
              `- Dependabot: https://github.com/${owner}/${repo}/security/dependabot`,
              `- Actions: https://github.com/${owner}/${repo}/actions`,
            ].join('\n');

            const maintenanceIssues = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: maintenanceLabel,
              per_page: 100,
            });

            const previousMaintenance = maintenanceIssues.data.filter((i) => i.title.startsWith('ðŸ” Weekly security + maintenance checklist'));
            for (const oldIssue of previousMaintenance) {
              if (oldIssue.title !== mainTitle) {
                await github.rest.issues.update({ owner, repo, issue_number: oldIssue.number, state: 'closed' });
              }
            }

            const existingMain = previousMaintenance.find((i) => i.title === mainTitle);
            if (existingMain) {
              await github.rest.issues.update({ owner, repo, issue_number: existingMain.number, body: mainBody });
            } else {
              await github.rest.issues.create({ owner, repo, title: mainTitle, body: mainBody, labels: [maintenanceLabel] });
            }

            const enhancementTitle = 'ðŸ§© Monthly enhancement intake from user feedback';
            const enhancementBody = [
              'This issue is auto-generated to ensure at least one enhancement candidate is always tracked.',
              '',
              '## Enhancement backlog starter',
              '- [ ] Capture one concrete user pain point from support, issues, or docs feedback.',
              '- [ ] Define acceptance criteria and expected impact.',
              '- [ ] Add/update roadmap context in `docs/roadmap.md`.',
              '',
              '## Candidate details (fill in)',
              '- **User pain point:**',
              '- **Acceptance criteria:**',
              '- **Expected impact:**',
              '',
              '## Suggested metadata',
              `- Labels: \`${enhancementLabel}\`, \`${priorityLabel}\``,
              '- Link the final implementation PR back to this issue.',
            ].join('\n');

            const enhancementIssues = await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: enhancementLabel,
              per_page: 100,
            });
            const existingEnhancement = enhancementIssues.data.find((i) => i.title === enhancementTitle);
            if (!existingEnhancement) {
              await github.rest.issues.create({
                owner,
                repo,
                title: enhancementTitle,
                body: enhancementBody,
                labels: [enhancementLabel, priorityLabel],
              });
            }

            const trackedWorkflows = [
              'security.yml',
              'osv-scanner.yml',
              'security-maintenance-bot.yml',
              'ci.yml',
              'quality.yml',
            ];
            const now = Date.now();
            const staleMs = 14 * 24 * 60 * 60 * 1000;
            const weakSpots = [];

            for (const workflowFile of trackedWorkflows) {
              try {
                const runs = await github.rest.actions.listWorkflowRuns({
                  owner,
                  repo,
                  workflow_id: workflowFile,
                  per_page: 5,
                });
                const latest = runs.data.workflow_runs?.[0];
                if (!latest) {
                  weakSpots.push({
                    area: `Workflow: ${workflowFile}`,
                    observation: 'No workflow runs found.',
                    suggestion: `Trigger \`${workflowFile}\` manually and verify the workflow is enabled.`,
                  });
                  continue;
                }

                const updatedAt = new Date(latest.updated_at).getTime();
                if (Number.isFinite(updatedAt) && now - updatedAt > staleMs) {
                  weakSpots.push({
                    area: `Workflow freshness: ${workflowFile}`,
                    observation: `Latest run is stale (${latest.updated_at}).`,
                    suggestion: 'Review schedule/event triggers to ensure regular execution.',
                  });
                }

                const conclusion = latest.conclusion || latest.status || 'unknown';
                if (!['success', 'neutral', 'skipped'].includes(conclusion)) {
                  weakSpots.push({
                    area: `Workflow health: ${workflowFile}`,
                    observation: `Latest run ended with \`${conclusion}\` (run ${latest.html_url}).`,
                    suggestion: 'Triage failing jobs and convert recurring incidents into maintenance backlog items.',
                  });
                }
              } catch (error) {
                weakSpots.push({
                  area: `Workflow inspection: ${workflowFile}`,
                  observation: `Unable to inspect workflow runs (${error.message}).`,
                  suggestion: 'Check workflow file name/permissions and re-run this automation.',
                });
              }
            }

            const staleOpenIssues = (await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: maintenanceLabel,
              per_page: 100,
            })).data.filter((issue) => {
              if (issue.pull_request) return false;
              const updatedAt = new Date(issue.updated_at).getTime();
              return Number.isFinite(updatedAt) && now - updatedAt > staleMs;
            });

            if (staleOpenIssues.length > 0) {
              weakSpots.push({
                area: 'Maintenance issue hygiene',
                observation: `${staleOpenIssues.length} maintenance issue(s) have been open with no recent updates for 14+ days.`,
                suggestion: 'Close outdated trackers or convert them into actionable implementation issues with owners.',
              });
            }

            const weakTitle = `ðŸ› ï¸ Weekly maintenance weak-spot report (${weekOf})`;
            const weakBody = [
              'This issue is auto-generated to identify weaker spots in maintenance operations and propose concrete follow-up actions.',
              '',
              `Detected weak spots: **${weakSpots.length}**`,
              '',
              '| Area | Observation | Suggested action |',
              '| --- | --- | --- |',
              ...(weakSpots.length
                ? weakSpots.map((spot) => `| ${spot.area} | ${spot.observation} | ${spot.suggestion} |`)
                : ['| Baseline | No weak spots detected this week. | Keep current maintenance cadence and continue monitoring. |']),
              '',
              '## Suggested follow-up workflow',
              '- [ ] Convert high-impact weak spots into `enhancement` or `maintenance` issues.',
              '- [ ] Add acceptance criteria and expected impact to each follow-up issue.',
              '- [ ] Link implemented fixes back to this report and `docs/roadmap.md`.',
            ].join('\n');

            const weakOpen = (await github.rest.issues.listForRepo({
              owner,
              repo,
              state: 'open',
              labels: `${maintenanceLabel},${weakSpotLabel}`,
              per_page: 100,
            })).data.filter((i) => i.title.startsWith('ðŸ› ï¸ Weekly maintenance weak-spot report'));

            for (const oldIssue of weakOpen) {
              if (oldIssue.title !== weakTitle) {
                await github.rest.issues.update({ owner, repo, issue_number: oldIssue.number, state: 'closed' });
              }
            }

            const existingWeak = weakOpen.find((i) => i.title === weakTitle);
            if (existingWeak) {
              await github.rest.issues.update({ owner, repo, issue_number: existingWeak.number, body: weakBody });
            } else {
              await github.rest.issues.create({
                owner,
                repo,
                title: weakTitle,
                body: weakBody,
                labels: [maintenanceLabel, weakSpotLabel, priorityLabel],
              });
            }
